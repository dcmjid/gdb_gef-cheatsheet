\documentclass[a4paper,landscape]{article}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[bookmarks=true,colorlinks=true,linkcolor=black,citecolor=black,filecolor=black,urlcolor=black]{hyperref}
\usepackage{multicol}
\usepackage{geometry}
\geometry{top=1cm,left=1cm,right=1cm,bottom=1cm}
\pagestyle{empty}
\usepackage{color,soul}
\newcommand{\hlc}[2][yellow]{{\sethlcolor{#1} \hl{#2}}}
\definecolor{skyblue}{RGB}{0,255,255}
\newcommand{\gef}[1]{\hlc[skyblue]{#1}}

% Redefine section commands to use less space
\makeatletter
\renewcommand{\section}{\@startsection{section}{1}{0mm}%
                                {-1ex plus -.5ex minus -.2ex}%
                                {0.5ex plus .2ex}%x
                                {\normalfont\large\bfseries}}
\renewcommand{\subsection}{\@startsection{subsection}{2}{0mm}%
                                {-1explus -.5ex minus -.2ex}%
                                {0.5ex plus .2ex}%
                                {\normalfont\normalsize\bfseries}}
\renewcommand{\subsubsection}{\@startsection{subsubsection}{3}{0mm}%
                                {-1ex plus -.5ex minus -.2ex}%
                                {1ex plus .2ex}%
                                {\normalfont\small\bfseries}}
\makeatother

\setcounter{secnumdepth}{0} % Don't print section numbers
\setlength{\parindent}{0pt}
\setlength{\parskip}{3pt plus 0.5ex}
\begin{document}
%\raggedright
\footnotesize
\begin{multicols*}{3}
% multicol parameters
% These lengths are set only within the two main columns
%\setlength{\columnseprule}{0.25pt}
\setlength{\premulticols}{1pt}
\setlength{\postmulticols}{1pt}
\setlength{\multicolsep}{1pt}
\setlength{\columnsep}{2pt}

\begin{center}
     \Large{\textbf{Reversing with GDB and GEF}} \\
\end{center}

Gdb commands are \hl{highlighted in yellow},
while GEF commands are \gef{highlighted in cyan}.

\section{Starting GDB}
\texttt{gdb}\textit{ program }[\textit{core}|\textit{pid}] \\
\texttt{gdb}\textit{ gdb-options }[\texttt{-{}-args}\textit{ program args}]

At startup, gdb reads the following init files and executes their commands:
\texttt{/etc/gdb/gdbinit} and \texttt{\textasciitilde/.gdbinit}, plus \texttt{./.gdbinit},
if \texttt{set auto-load local-gdbinit} is set to \texttt{on}.

In addition to reading its config from \texttt{\textasciitilde/.gef.rc}, GEF can also be configured at runtime with \gef{\texttt{gef config}}.

Some options are:\\
\begin{tabular}{@{}ll@{}}
\texttt{-q}/\texttt{-{}-quiet}/\texttt{-{}-silent} & don't print version number on startup \\
\texttt{-h}/\texttt{-{}-help} & print help \\
\texttt{-{}-tty=}\textit{TTY} & use \textit{TTY} for I/O by debugged program \\
\texttt{-{}-nh} & do not read \texttt{\textasciitilde/.gdbinit} \\
\texttt{-x}\textit{ FILE} & execute GDB commands from \textit{FILE} \\
\texttt{-ix}\textit{ FILE} & like \texttt{-x} but execute before loading inferior \\
\texttt{-ex}\textit{ CMD} & execute a single GDB command; may be \\ & used multiple times and with \texttt{-x} \\
\texttt{-iex}\textit{ CMD} & like \texttt{-ex} but before loading inferior \\
\texttt{-s}\textit{ SYMFILE} & read symbols from \textit{SYMFILE} \\
% \texttt{-{}-readnow} & fully read symbol files on first access \\
% \texttt{-{}-readnever} & do not read symbol files \\
\texttt{-{}-write} & set writing into executable and core files \\
\end{tabular}

To quit, \hl{\texttt{q}[\texttt{uit}]} or \textit{Ctrl-D}.

You can invoke commands on the standard shell by using:\\
\hl{\texttt{shell}\textit{ command-string}}
or simply: \hl{\texttt{!}\textit{command-string}}

You can abbreviate a gdb command to the first few letters of the command name, if that
abbreviation is unambiguous; and you can repeat certain gdb commands by typing just
\textit{Return}. You can also use the \textit{TAB} key to get gdb to fill out the rest of a word in a command (or to show you the alternatives available, if there is more than one possibility).

You can always ask for information on commands by using \hl{\texttt{h}[\texttt{elp}]} and \gef{\texttt{gef help}},
or use \hl{\texttt{apropos} \textit{regexp}} to search for commands matching \textit{regexp}.

\gef{\texttt{tmux-setup}} checks whether GDB is being spawn from inside a tmux session, and if so, will split the pane vertically, and configure the context to be redirected to the new pane.

\gef{\texttt{checksec}}, inspired from \texttt{checksec.sh}, provides a convenient way to determine which security protections are enabled in a binary.

\subsection{Debugging targets}
\hl{\texttt{target} \textit{type param}} connects to machines, processs, or files; e.g.
\texttt{target remote | sshpass -p\textit{pw} ssh -T [\texttt{-p} \textit{port}] [\textit{user}\texttt{@}\textit{host}] gdbserver - \textit{prog} [\textit{args}]}

\gef{\texttt{gef-remote}} is a wrapper for the \texttt{target remote} command,
which includes a QEMU-mode with \texttt{-q}.

\subsection{Processes and threads}
By default, when a program forks, gdb will continue to debug the parent process and
the child process will run unimpeded.
If you want to follow the child process instead of the parent process, use the command
\hl{\texttt{set follow-fork-mode}}.
On Linux, if you want to debug both the parent and child processes, use the command
\hl{\texttt{set detach-on-fork}}.

If you issue a run command to gdb after an \texttt{exec} call executes, the new target restarts.
To restart the original program, use the \texttt{file} command with the parent executable name
as its argument. By default, after an \texttt{exec} call executes, gdb discards the symbols of the
previous executable image. You can change this behaviour with the \hl{\texttt{set follow-exec-mode}}.

gdb lets you run and debug multiple programs in a single session;
in the most general case, you can have multiple threads
of execution in each of multiple processes, launched from multiple executables.
See the manual for details.

\section{Getting information}
\hl{\texttt{i}[\texttt{nfo}]} is for describing the state of your program. For
example, you can show the arguments passed to a function with \texttt{info args};
you can get a complete list of the info sub-commands with \texttt{help info}.

\gef{\texttt{process-status}} provides an exhaustive description of the current running process, by extending the information provided by \hl{\texttt{info proc}}, with information from procfs.

\gef{\texttt{vmmap}} displays the entire memory space mapping;
\gef{\texttt{xfiles}} is a more convenient representation of the GDB native command, \hl{\texttt{info
files}} to list the names of targets and files being debugged.

You can assign the result of an expression to an environment variable with \hl{\texttt{set}}.
For example, you can set the gdb prompt to a \$-sign with \texttt{set prompt \$}.

\hl{\texttt{show}} is for describing the state of gdb itself. You can
change most of things by using the related command \texttt{set};
for example, you can control what number system is used for displays with \texttt{set
radix}, or simply inquire which is in use with \texttt{show radix}.

To display all settable parameters and their values, you can use
\texttt{show} with no arguments; you may also use \texttt{info set}: both print the same.

\section{Logging output}
Logging can be enabled/disabled with \hl{\texttt{set logging on}/\texttt{off}}. \\
\hl{\texttt{set logging file}\textit{ file}} changes the current logfile
(default: \texttt{gdb.txt}).
\hl{\texttt{show logging}} shows current logging settings; other settings are
\texttt{logging overwrite}, and
\texttt{logging redirect} to choose whether the output goes to both terminal and logfile.

\section{Starting your program}
\hl{\texttt{r}[\texttt{un}] [\textit{args}]},
\hl{\texttt{start} [\textit{args}]} and
\hl{\texttt{starti} [\textit{args}]}

\texttt{start} does the equivalent of setting a temporary breakpoint
at the beginning of \emph{main} and invoking \texttt{run}.
\texttt{starti} does the equivalent of setting a temporary breakpoint
at the first instruction of a program's execution and invoking \texttt{run}.
For programs containing an elaboration phase, \texttt{starti}
will stop execution at the start of the elaboration phase.
In GEF, see also \gef{\texttt{entry-break}}/\gef{\texttt{start}}.

\textit{args} may include ``*'', or ``[...]''; they are expanded using the
shell that will start the program (specified by the \texttt{\$SHELL} environment
variable).  Input/output redirection with ``>'', ``<'', or ``>{}>'' are also allowed. \\
With no arguments these commands use arguments last specified;
to cancel previous arguments, use \hl{\texttt{set args}} without arguments.
To start the inferior without using a shell, use \hl{\texttt{set startup-with-shell off}}.

\hl{\texttt{set disable-randomization on}} (enabled by default) turns off ASLR;
you can get the same behavior by using: \\
\hl{\texttt{set exec-wrapper setarch `uname -m` -R}}. In GEF, see \gef{\texttt{aslr}}.

\gef{\texttt{elf}[\texttt{-info}]} provides some basic information on the currently loaded program.

\subsection{Environment}
\hl{\texttt{show environment} [\textit{varname}]}, \hl{\texttt{set environment varname} [\texttt{=}\textit{value}]} and \hl{\texttt{unset environment}\textit{ varname}}

The changes are for your program (and the shell gdb uses to launch it), not for gdb itself.
If your shell runs an initialization file when started non-interactively, it may affect your program.

\hl{\texttt{set cwd }[\textit{dir}]} sets the inferior's working directory to \textit{dir},
while \\ \hl{\texttt{cd }[\textit{dir}]} changes gdb working directory.

\hl{\texttt{tty}} is an alias for \texttt{set inferior-tty}, which can be used
to set the terminal terminal that will be used for future runs.

If the currently debugged process was compiled with the Smash Stack Protector (SSP) - i.e. the \texttt{-fstack-protector} flag was passed to the compiler, \gef{canary} will display the value of the canary.

\gef{\texttt{hijack-fd} \textit{fd-num} \textit{newfile}}
 can be used to modify file descriptors of the debugged process.

\gef{\texttt{set-permission}} facilitates the exploitation process, by changing the permission rights on a specific page directly from the debugger.

\section{Checkpoint}
On Linux gdb can save a snapshot of a program's state, called
a \emph{checkpoint}, and come back to it later.
Returning to a checkpoint effectively undoes everything that has happened in the program since the checkpoint was saved.

\hl{\texttt{checkpoint}} saves a snapshot;
\hl{\texttt{info checkpoints}} lists the checkpoints that have been saved,
while
\hl{\texttt{restart }\textit{checkpoint-id}} restores the state that was saved.
All program variables, registers, stack frames etc. will be returned to the values
that they had when the checkpoint was saved.
Note that breakpoints, gdb variables, command history etc. are not affected
by restoring a checkpoint. In general, a checkpoint only restores things that
reside in the program being debugged, not in the debugger.
Finally, \hl{\texttt{delete checkpoint}\textit{ checkpoint-id}} deletes the corresponding
checkpoint.

Returning to a previously saved checkpoint will restore the user state of the program
being debugged, plus a significant subset of the system (OS) state, including file pointers.
% It won't ``un-write'' data from a file, but it will rewind the file pointer to the previous location,
% so that the previously written data can be overwritten. For files opened in read mode, the
% pointer will also be restored so that the previously read data can be read again.

\section{Stop and continue}
\begin{itemize}
\item \emph{breakpoints} make your program stop whenever a certain point in the program is reached.  For each breakpoint, you can add conditions to control in finer detail whether your program stops.
\hl{[\texttt{t}]\texttt{b}[\texttt{reak}] \textit{location} [\texttt{if} \textit{condition}]} sets a [temporary] breakpoint at the given \textit{location} [, and given \textit{condition}]. When called without any arguments, \hl{\texttt{break}} sets a breakpoint at the next instruction to be executed in the selected stack frame. To use an address as a location, you must prepend it with \texttt{*}; e.g. \texttt{*0x1234}.
	\begin{itemize}
	\item {}[\texttt{t}]\texttt{hbreak} \textit{args} sets [temporary] \emph{hardware} breakpoints
	\item \texttt{rbreak} [\textit{file}\texttt{:}]\textit{regex} set breakpoints on all functions [of \textit{file}] matching the regular expression \textit{regex}.
	\end{itemize}
\hl{\texttt{info break}[\texttt{points}] [\textit{list}]} prints a table of all breakpoints, watchpoints, and catchpoints (or the ones specified in \textit{list}).
\hl{\texttt{clear} \textit{location}} and \hl{\texttt{delete} [\texttt{breakpoints}] \textit{list}} delete breakpoints.

\hl{\texttt{ignore} \textit{bnum} \textit{n}} sets the ignore count of breakpoint \textit{bnum} to \textit{n} (0 to make it stop the next time breakpoint \textit{bnum} is reached).
\item \gef{\texttt{format-string-helper}} creates a GEF specific type of breakpoints dedicated to detecting potentially insecure format string when using the GlibC library.
\item \gef{\texttt{pie} \ldots} handles PIE breakpoints.
\item \emph{watchpoints}, AKA \emph{data breakpoints}, are special breakpoints that stop your program when the value of an expression changes.
	\hl{\texttt{watch} [\texttt{-l}[\texttt{ocation}]] \textit{expr} [\texttt{thread} \textit{thread-id}]} sets a watchpoint for expression \textit{expr}.
If the command includes \textit{thread-id} argument, gdb breaks only
when the corresponding thread changes the value of expr.
Ordinarily a watchpoint respects the scope of variables in \textit{expr}; however,
\texttt{-location} tells gdb to instead watch the memory referred to
by \textit{expr}.
	\begin{itemize}
	\item \hl{\texttt{rwatch}} sets a \emph{read} watchpoint
	\item \hl{\texttt{awatch}} sets an \emph{access (i.e., read or write)} watchpoint
	\item \hl{\texttt{info watchpoints [\textit{list}]}} prints a list of watchpoints
	\end{itemize}
\item \emph{catchpoints} stop your program when a certain kind
of event occurs, such as the throwing of a C++ exception or the loading of a library.
\hl{\texttt{catch} \textit{event}} stops when \textit{event} occurs; it can be:
a C++/Ada exception event (see the manual); \texttt{exec}, \texttt{fork},
\texttt{syscall [\textit{name} | \textit{number} | \texttt{g}[\texttt{roup}]:\textit{groupname}]},
[\texttt{un}]\texttt{load} \textit{regexp}, \texttt{signal }[\textit{signal...} | \texttt{all}].
Use \hl{\texttt{set stop-on-solib-events 1}} to stop the target when a shared library is loaded or unloaded.
\item To stop when your program receives a signal, use the \hl{\texttt{handle}} command
\end{itemize}
A *point can have any of several different states of enablement:
\begin{itemize}
\item Enabled --- \hl{\texttt{enable} [\texttt{breakpoints}] [\textit{list}]}
\item Disabled --- \hl{\texttt{disable} [\texttt{breakpoints}] [\textit{list}]}
\item Enabled once --- \hl{\texttt{enable} [\texttt{breakpoints}] \texttt{once} [\textit{list}]}
\item Enabled for a count --- \hl{\texttt{enable} [\texttt{breakpoints}] \texttt{count} \textit{n} [\textit{list}]}
\item Enabled for deletion --- \hl{\texttt{enable} [\texttt{breakpoints}] \texttt{delete} [\textit{list}]}
\end{itemize}
\hl{\texttt{condition} \textit{bnum} [\textit{expr}]} sets or removes a condition for *point \textit{bnum}.

You can give any *point a series of commands to execute
when your program stops due to that *point; see \hl{\texttt{commands}}.

When a *point is hit, GEF displays the context (current instruction, register values, stack, \ldots) via its
\gef{\texttt{context}} command; its layout can be configured, see
\gef{\texttt{gef config context.layout}}.

\hl{\texttt{save breakpoints} \textit{filename}} saves all current *point definitions together with their commands and ignore counts, into \textit{filename}.
To read the saved breakpoint definitions, use \hl{\texttt{source}}.

\hl{\texttt{info program}} displays information about the status of your program.

\section{Continuing and Stepping}
\hl{\texttt{c} [\texttt{continue}] [\textit{ignore-count}]}
resumes program execution; the optional argument
\textit{ignore-count} allows you to specify a further number of times to ignore a breakpoint at this location (if the execution has stopped due to a breakpoint; otherwise the argument is ignored).

To resume execution at a different place, you can use \hl{\texttt{return} [\textit{expr}]} to go back to the
calling function; or \hl{\texttt{j}[\texttt{ump}]} to go to an arbitrary location.
Note that \texttt{return} does not resume execution; it leaves the program stopped in the
state that would exist if the function had just returned. In contrast, \texttt{finish} command
resumes execution until the selected stack frame returns naturally.

\hl{\texttt{s}[\texttt{tep}] [\textit{count}]} continue running your program until control reaches a different source line [\textit{count} times]. \hl{\texttt{n}[\texttt{ext}] [\textit{count}]} continues to the next source line in the current stack frame.

\hl{\texttt{fin}[\texttt{ish}]} continues running until just after function in the selected stack frame returns.
\hl{\texttt{u}[\texttt{ntil}]}, without arguments, continues running until a source line past the current line, in the current stack frame, is reached. It is like the next command, except that when until encounters a jump, it automatically continues execution until the program counter is greater than the address of the jump. \hl{\texttt{u}[\texttt{ntil}] \textit{location}} continue running until either the specified \textit{location} is reached, or the current stack frame returns.

\hl{\texttt{stepi}/\texttt{si} \textit{count}} and \hl{\texttt{nexti}/\texttt{ni} \textit{count}} work on machine instructions, instead of source lines.

\subsection{Emulation}
If you have installed \emph{Unicorn} emulation engine and its Python bindings,
\gef{\texttt{unicorn-emulate} / \texttt{emu}} replicates the current memory mapping (including the page permissions) for you, and by default (i.e. without any additional argument), it will emulate the execution of the instruction about to be executed (i.e. the one pointed by \texttt{\$pc}) and display which register(s) is(are) tainted by it.

\section{Record, replay and reverse execution}
TODO

\section{Examining the stack}
One of the stack frames is selected by gdb and many commands refer implicitly to it.
% In particular, whenever you ask gdb for the value of a variable in your program, the value is found in the selected frame.
There are commands to select whichever frame you are interested in (\hl{\texttt{f}[\texttt{rame}] [\textit{n}|\textit{addr}]}, \hl{\texttt{up} [\textit{n}]} and \hl{\texttt{down} [\textit{n}]}).
When your program stops, gdb automatically selects the currently executing frame and
describes it briefly, similar to the \hl{\texttt{f}[\texttt{rame}]} command (without argument;
for a more verbose description, \hl{\texttt{info f[\textit{rame}] [\textit{addr}]}}).

\hl{\texttt{info args}} prints the arguments of the selected frame, while \hl{\texttt{info locals}}
prints the local variables.

A backtrace is a summary of how your program got where it is. It shows one line per frame,
for many frames, starting with the currently executing frame (frame zero), followed by its
caller (frame one), and on up the stack.
To print a backtrace of the entire stack, use the \hl{\texttt{backtrace}} command, or its alias \hl{\texttt{bt}}.

\section{Code and data}
\hl{\texttt{disassemble}}
dumps a range of memory as machine instructions, with
the raw instructions in hex with the \texttt{/r} modifier.
The arguments specify a range of addresses to dump,
in one of two forms: \textit{start}\texttt{,}\textit{end} to disassemble
from \textit{start} (inclusive) to \textit{end} (exclusive), and
\textit{start}\texttt{,+}\textit{length} to disassemble
from \textit{start} (inclusive) to \textit{start+length} (exclusive).
See also \gef{\texttt{capstone-disassemble}} or simply \gef{\texttt{cs}} for using \emph{Capstone} disassembler
(different syntax, check the help out).

If you have installed \emph{Keystone}, then GEF can assemble native instructions directly to opcodes of the architecture you are currently debugging with \gef{\texttt{assembler}} or its alias \gef{\texttt{asm}}.

\gef{\texttt{registers} [$r_1$ [$r_2$ \ldots]]} displays registers and dereference any pointers
(in plain gdb you can see register values with \hl{\texttt{info registers}}); \gef{[\texttt{edit-}]\texttt{flags} [\{\texttt{+}|\texttt{-}|\texttt{\textasciitilde}\} \textit{flag-name} [\ldots]]}
shows/edits the flag register.

\hl{\texttt{p}[\texttt{rint}] [\texttt{/}\textit{f}] \textit{expr}} prints the
value of expression \textit{expr}
(in the source language). By default it's printed in a format appropriate to its data type;
you can choose a different format by specifying \texttt{/}\textit{f}, where \textit{f} is one of: o(octal), x(hex), d(decimal), u(unsigned decimal), t(binary), f(float), a(address), c(char), s(string) and z(hex, zero padded on the left).

An expression in the form \texttt{\{\textit{type}\}} \textit{addr}
refers to an object of type \textit{type} stored at address \textit{addr} in memory.

The \texttt{print}ed expression may include calls to functions in the program being debugged;
use \hl{\texttt{call} \textit{addr}} to call a function without printing its return value.

\hl{\texttt{x}[/\textit{fmt}] [\textit{addr}]} examines memory;
the default for addr is usually just after the last address examined.
\textit{fmt} is a repeat count followed by a format letter and a size letter.
Format letters are o(octal), x(hex), d(decimal), u(unsigned decimal),
t(binary), f(float), a(address), i(instruction), c(char), s(string)
and z(hex, zero padded on the left).
Size letters are b(byte), h(halfword), w(word), g(giant, 8 bytes).
The specified number of objects of the specified size are printed
according to the format.  If a negative number is specified, memory is
examined backward from the address.

\gef{\texttt{hexdump} \{\texttt{qword}|\texttt{dword}|\texttt{word}|\texttt{byte}\} \textit{location} [\texttt{l}\textit{size}] [\texttt{up}|\texttt{down}]}

\gef{\texttt{memory} \ldots} adds or removes address ranges to the memory view.

The \gef{\texttt{dereference}} command (also aliased \gef{\texttt{telescope}} for PEDA former users) aims to simplify the dereferencing of an address in GDB to determine the content it actually points to.

The \gef{\texttt{\$}} command attempts to mimic WinDBG \texttt{?} command;
when provided one argument, it will evaluate the expression, and try to display the result with various formats.
With two arguments, it will simply compute the delta between them.

\gef{\texttt{heap} \ldots} is a base command to get information about the Glibc heap structure; moreover,
\gef{\texttt{heap-analysis-helper}} aims to help the process of identifying Glibc heap inconsistencies by tracking and analyzing allocations and deallocations.

\gef{\texttt{nop}} and \gef{\texttt{patch}} writes values into memory.

\hl{\texttt{dump}}, \hl{\texttt{append}}, and \hl{\texttt{restore}} copy data between target memory and a file. \texttt{dump} and \texttt{append} write data to a file, whereas \texttt{restore} reads data from a file back into the inferior's memory.

\gef{\texttt{print-format} / \texttt{pf}} dumps an arbitrary location as an array of bytes following the syntax of the programming language specified.

\gef{\texttt{shellcode}} is a command line client for \texttt{@JonathanSalwan} shellcodes database.

\gef{\texttt{stub}} allows you stub out functions, optionally specifying the return value.

\subsection{Automatic display}
If you find that you want to print the value of an expression frequently (to see how it
changes), you might want to add it to the automatic display list so that gdb prints its
value each time your program stops.
\hl{\texttt{display}[\texttt{/}\textit{fmt}] \{\textit{expr}|\textit{addr}\}}
adds the expression/address to the list to display each time your program stops.

\subsection{Search memory}
\hl{\texttt{find} [\texttt{/}\textit{size-char}] [\texttt{/}\textit{max-count}] \textit{start-address}\texttt{,} \{\textit{end-address}|\texttt{+}\textit{length}\}, \textit{expr1} [\texttt{,} \textit{expr2 ...}]} where
\textit{size-char} is one of b,h,w,g for 8,16,32,64 bit values respectively,
and if not specified the size is taken from the type of the expression
in the current language.

Note that this means for example that in the case of C-like languages
a search for an untyped 0x42 will search for "(int) 0x42"
which is typically four bytes, and a search for a string "hello" will
include the trailing \texttt{'\textbackslash 0'}.  The null terminator can be removed from
searching by using casts, e.g.: {char[5]}"hello".

The address of the last match is stored as the value of \texttt{\$\_}.
Convenience variable \texttt{\$numfound} is set to the number of matches.

\gef{\texttt{search-pattern}}, alias \gef{\texttt{grep}}, allows you to search for a specific pattern at runtime in all the segments of your process memory layout.

\gef{\texttt{pattern} \ldots} creates or searches a De Bruijn cyclic pattern to facilitate determining offsets in memory; the algorithm is the same as the one in \emph{pwntools}, and can therefore be used in conjunction.

\gef{\texttt{scan} \textit{haystack} \textit{needle}} searches for addresses that are located in memory mapping \textit{haystack} that belonging to another, \textit{needle};
its arguments are grepped against the processes memory mappings (just like \gef{\texttt{vmmap}} to determine the memory ranges to search).

\section{Examining the Symbol Table}
\hl{\texttt{info address} \textit{symbol}} describe where the data for \textit{symbol} is stored.

\hl{\texttt{info symbol }\textit{addr}} prints
the name of a symbol which is stored at the address \textit{addr}. If no symbol
is stored exactly at \textit{addr}, gdb prints the nearest symbol and an offset from it.
This is the opposite of the \texttt{info address} command. You can use it to find out
the name of a variable or a function given its address.

\gef{\texttt{xinfo}} displays all the information known to gef about the specific address given as argument.

\rule{1.0\linewidth}{0.25pt}
\scriptsize
Copyright \copyright 2018 by zxgio; cheat-sheet built on \today

This cheat-sheet may be freely distributed under the terms of the GNU
General Public License; the latest version can be found at: \\
% \url{https://github.com/zxgio/r2-cheatsheet/}
\end{multicols*}
\end{document}
